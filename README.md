# DOCKER 
A quick guide on docker

# Check installed version
```bash
docker --version
# or
docker -v
```

```bash
# for help
docker --help

# for help for a command
docker <command> --help
```


# Basic Steps

1. Create a **Dockerfile** file
2. To **build** a docker image
    ```bash
    # basic build command
    docker build .
    ```
3. To **run** a container for the image

    ```bash
    # basic run command
    docker run <image-id>

    # if you need to work with a exposed port number
    docker run -p 3000:80 15e39aabf3d848db3fd0484b143ac09864bdfb765a7ccca3c89376b491477ecf
    ```
4. To **list** all cotainers
    ```bash
    # show all running containers
    docker ps

    # show all (running + stopped) containers
    docker ps -a
    ```
5. To **stop** a running container
    ```bash
    docker stop <container-name>
    ```

# To run a container from an official docker image

For python, docker already has an official image. To _run a container_ for python in our system even when we don't have an image for python in our system, we can use the **run** command. Below command downloads the python image from Docker HUB
```bash
docker run python
```
Alternatively, we can also _pull the official_ container for python from Docker HUB using the **pull** command
```bash
docker pull python
```

**Important Note** : 
* Whenever we need a container, we first need to have an Image
* In most scenarios, our application (app that we have written) would be dependent on some image(s) like _Python_, _Django_, _MongoDB_
* So in order to create an image for our application, we need to have the images of these dependencies in our system also
* To download these dependencies (images), we can pull a image from Docker Hub directly or create a **Dockerfile** where we list down these depencies and when we run a **build** command, Docker will pull these dependencies for us automatically

# Writing a simple Dockerfile

```bash
# layer 1 --> pull dependent image
FROM node
# layer 2 --> declare a working directory
WORKDIR /app
# layer 3 --> copy everything from current dir to /app dir in image
COPY . /app
# layer 4 -->run npm install in image
RUN npm install
# layer 5 --> expose port 80
EXPOSE 80
# layer 6 --> run command <npm server.js> when container is executed
CMD ["node", "server.js"]
```

# Layers
* In the [Writing a simple Dockerfile](#writing-a-simple-dockerfile) section, we have 6 steps. Each step is a layer and layer makes up a Image
* Docker keeps a cache for the result of each layer during build phase. So when we execute the _build_ command again, if docker identifies that there will be no change in the result for a layer, _then it uses the cache_ for that layer
* If docker identifies that there will be a change in the result for a layer, then for that layer and for the subsequent layers, docker will execute them again and not use cache
* So we can keep these points in mind to __optimize__ the execution time for _build_ command by writing our Dockerfile in such a way that layers which don't usually change are kept at top and rest at bottom

# Important Commands
1. **build**
    ```bash
    # build a image
    docker build .
    ```
2. **run**
    ```bash
    # run a image i.e. create a container
    docker run <image-id>
    ```
3. **To see all images and containers** --> 
    > There is better way to do the below activities using the image & container management commands. Check point **12**
    ```bash
    # list running images
    docker images

    # list running containers
    docker ps

    # list all containers
    docker ps -a
    ```
4. **stop**
    ```bash
    # stop a container
    docker stop <container-name>
    ```
5. **start**
    ```bash
    # to re-start a container
    docker start <container-name>
    ```
6. **rm** & **rmi**
    ```bash
    # remove a single container
    docker rm <container-name>

    # remove multiple containers
    docker rm <container-name-1> <container-name-2> ... <container-name-n>
    
    # remove a single image
    docker rmi <image-id>

    # remove multiple images
    docker rmi <image-id-1> <image-id-2> ... <image-id-n>

    # remove container after it has been stopped
    docker run -p 3000:80 --rm <image-id>
    ```

7. **detached and attached mode**
    > **run** starts container in attached mode by default & **start** starts container in detached mode by default. We can modify this by using **-d** & **-a** flags 
    ```bash
    # to start a container using run command in detached mode
    docker run -d <image-id>

    # to start a container using start command in attached mode
    docker start -a <container-name>
    ```
8. **attach**
    ```bash
    # to attach to detached running container
    docker attach <container-name>
    ```
9. **logs**
    ```bash
    # to see the logs generated by the container
    docker logs <container-name>

    # to see the time-stamp also
    docker logs <container-name> -t

    # to see fixed line in logs (in this example its 2 lines)
    docker logs <container-name> -n 2

    # to tail logs of a running container
    docker logs <container-name> -f
    ```
10. **See all Images and Containers**
    ```bash
    # to see all Images
    docker image ls

    # to see running containers
    docker container ls

    # to see all (running + stopped) containers
    docker container ls -a
    ```
11. **Remove Image and Container**
    ```bash
    # remove one or multiple image(s)
    docker image rm <image-id-1> ... <image-id-n>

    # remove all images
    docker image prune

    # remove one or multiple container(s)
    docker container rm <container-name-1> ... <container-name-n>

    # remove all containers
    docker container prune
    ```
12. **Interactive Mode**
    ```bash
    # run container in interactive mode
    docker run -it <image-id>

    # start container in interactive mode
    docker start <container-name> -a -i
    ```

13. **inspect** & **history**
    ```bash
    docker image inspect <image-id>
    docker image history <image-id>
    ```
